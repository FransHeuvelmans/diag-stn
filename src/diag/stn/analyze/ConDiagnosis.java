/*
 * Copyright 2016 Frans van den Heuvel.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package diag.stn.analyze;

import diag.stn.STN.DEdge;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;

/**
 * A Consistency Diagnosis
 * @author Frans van den Heuvel
 */
public class ConDiagnosis
{
    private ArrayList<DEdge> faultyEdges;
    private ArrayList<DEdge> correctEdges;
    
    public ConDiagnosis()
    {
        faultyEdges = new ArrayList();
        correctEdges = new ArrayList();
    }
    
    public void addFaultyEdge(DEdge wrong)
    {
        if(correctEdges.contains(wrong))
            System.err.println("How can some edge be faulty and correct?");
        if(!faultyEdges.contains(wrong))
            faultyEdges.add(wrong);
    }
    
    public void addCorrectEdge(DEdge right)
    {
        if(!correctEdges.contains(right))
            correctEdges.add(right);
    }
    
    public boolean edgeCorrect(DEdge de)
    {
        return correctEdges.contains(de);
    }
    
    /**
     * Is some edge already solved with a certain diagnosis ?
     * @param de
     * @return 
     */
    public boolean edgeSolved(DEdge de)
    {
        return faultyEdges.contains(de);
    }
    
    public boolean pathSolved(GraphPath p)
    {
        for(int i = 1; i < p.stepSize(); i++)
        {
            DEdge edgeIn = p.getStepE(i);
            if(faultyEdges.contains(edgeIn))
                return true;
        }
        return false;
    }
    
    public boolean isSubsetOrEqual(ConDiagnosis other)
    {
        for(DEdge fault : faultyEdges)
        {
            if(!other.edgeSolved(fault))
                return false;
        }
        // compare the 2, for removal of all non-minimal condiag
        return true;
    }
    
    public int solSize()
    {
        return faultyEdges.size();
    }
    
    public ConDiagnosis copy()
    {
        ConDiagnosis theCopy = new ConDiagnosis();
        for(DEdge coredge: correctEdges)
            theCopy.addCorrectEdge(coredge);
        for(DEdge wrngedge : faultyEdges)
            theCopy.addFaultyEdge(wrngedge);
        return theCopy;
    }
    

    public void printDiagnosis()
    {
        System.out.print("Abnormal = {");
        for(DEdge fedge : faultyEdges)
        {
            System.out.print("d" + fedge.getStart().getName() + "," 
                    + fedge.getEnd().getName() + " \u02C4 ");
        }
        System.out.print("} , d-rest = normal\n");
    }
    
    /**
     * Print all diagnosis in disjunctive normal form.
     * @param all All Different ConDiagnosis objects generated by some analyst.
     */
    public static void printAllDiag(ConDiagnosis[] all)
    {
        int iter = 1;
        System.out.println("=== Consistency based diagnosis overview ===");
        for(ConDiagnosis d : all)
        {
            System.out.println("Diagnosis: " + iter);
            d.printDiagnosis();
            iter++;
        }
    }
}
